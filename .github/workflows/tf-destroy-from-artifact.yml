name: TF Destroy (from saved state)

on:
  workflow_dispatch:
    inputs:
      run_id:
        description: "GitHub Actions run ID that produced the state artifact"
        required: true
      artifact_name:
        description: "Artifact name (default: tfstate-<run_id>-<attempt>)"
        required: false
        default: ""

permissions:
  contents: read
  id-token: write          # OIDC to GCP
  actions: read            # fetch artifacts from the referenced run

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GCP_REGION:     ${{ secrets.GCP_REGION }}
  GCP_ZONE:       ${{ secrets.GCP_ZONE }}
  ALLOWED_CIDR:   ${{ secrets.ALLOWED_CIDR }}

  TF_IN_AUTOMATION: true
  TF_INPUT: false
  TF_CLI_ARGS_destroy: -auto-approve -lock-timeout=5m

jobs:
  destroy:
    runs-on: ubuntu-latest
    environment: gcpa-variables

    steps:
      - uses: actions/checkout@v4

      - name: Auth to Google Cloud (WIF)
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WIF_PROVIDER }}
          service_account:           ${{ secrets.GCP_WIF_SA }}

      - uses: google-github-actions/setup-gcloud@v2
      - uses: hashicorp/setup-terraform@v3

      - name: Clear gcloud impersonation
        shell: bash
        run: |
          gcloud config unset auth/impersonate_service_account || true
          unset CLOUDSDK_AUTH_IMPERSONATE_SERVICE_ACCOUNT || true
          gcloud auth list

      # Download the saved tfstate from the specified run
      - name: Resolve & download state artifact
        id: get_art
        shell: bash
        run: |
          set -euo pipefail
          RUN_ID="${{ inputs.run_id }}"
          JSON=$(gh api -H "Accept: application/vnd.github+json" \
            /repos/${{ github.repository }}/actions/runs/${RUN_ID}/artifacts)

          if [[ -z "${{ inputs.artifact_name }}" ]]; then
            ATTEMPT=$(gh api -H "Accept: application/vnd.github+json" \
              /repos/${{ github.repository }}/actions/runs/${RUN_ID} --jq '.run_attempt')
            ART_NAME="tfstate-${RUN_ID}-${ATTEMPT}"
          else
            ART_NAME="${{ inputs.artifact_name }}"
          fi

          echo "Looking for artifact: ${ART_NAME}"
          ART_ID=$(echo "$JSON" | jq -r --arg NAME "$ART_NAME" '.artifacts[] | select(.name==$NAME) | .id')

          if [[ -z "$ART_ID" || "$ART_ID" == "null" ]]; then
            echo "Artifact '${ART_NAME}' not found for run ${RUN_ID}"
            echo "Available artifacts:"
            echo "$JSON" | jq -r '.artifacts[].name'
            exit 1
          fi

          mkdir -p terraform/tfstate
          gh api -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/${{ github.repository }}/actions/artifacts/${ART_ID}/zip > /tmp/state.zip
          unzip -o /tmp/state.zip -d terraform/tfstate
          ls -al terraform/tfstate
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Use local backend pointing to the downloaded state and destroy
      - name: Init (local backend) & destroy
        working-directory: terraform
        shell: bash
        run: |
          set -euo pipefail
          cat > backend_local.tf <<'HCL'
          terraform {
            backend "local" {
              path = "tfstate/terraform.tfstate"
              lock = true
            }
          }
          HCL

          terraform init -reconfigure
          terraform state list || true

          CIDR="${{ secrets.ALLOWED_CIDR }}"
          terraform destroy \
            -var="project_id=${GCP_PROJECT_ID}" \
            -var="region=${GCP_REGION}" \
            -var="zone=${GCP_ZONE}" \
            -var="allowed_cidr=${CIDR}"

      - name: Cleanup
        if: always()
        working-directory: terraform
        run: rm -f backend_local.tf || true
